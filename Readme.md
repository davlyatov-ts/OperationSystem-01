-	Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin,
-	поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. 
-	В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, 
-	который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
-	
-	Ответ
-	системный вызов команды CD -> chdir("/tmp")
________________________________________________________________________________________
-	Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
-	
-	➜  ~ file /dev/tty
-	/dev/tty: character special (5/0)
-	➜  ~ file /dev/sda
-	/dev/sda: block special (8/0)
-	➜  ~ file /bin/bash
-	/bin/bash: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2a9f15789-	0930ced4c3ad0e74fc1b1b84aad71e6, for GNU/Linux 3.2.0, stripped	
-	
-	Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
-	
-	Ответ
-	Файл базы типов - /usr/share/misc/magic.mgc
-	в тексте это:

-	openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

-	так же ищет пользовательские файлы, по всей видимости

-	stat("/home/alex/.magic.mgc", 0x7ffedefbea50) = -1 ENOENT (Нет такого файла или каталога)
-	stat("/home/alex/.magic", 0x7ffedefbea50) = -1 ENOENT (Нет такого файла или каталога)
-	openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (Нет такого файла или каталога)
-	stat("/etc/magic", {st_mode=S_IFREG|0644, st_size=111, ...}) = 0
-	openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
___________________________________________________________________________________________________
-	Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом 
-	сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, 
-	место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления 
-	открытого удаленного файла (чтобы освободить место на файловой системе).
-	
-	Ответ
-	Использовал vim
-	lsof -p 10174
-	vim     10174   pi    4u   REG    8,5    16384 1580985 /home/pi/repo/netology/OperationSystem-01/.Readme.md.swp
-	echo '' >/proc/1126/fd/4
-	где 1126 - PID процесса vi
-	4 - дескриптор файла , который предварительно удалил. 
___________________________________________________________________________________________________________
-	Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
-	
-	Ответ
-	"Зомби" процессы, в отличии от "сирот" освобождают свои ресурсы, но не освобождают запись в таблице процессов. 
-	запись освободиться при вызове wait() родительским процессом.
______________________________________________________________________________________________________
-	В iovisor BCC есть утилита opensnoop:
-	
-	Ответ
-	rootvagrant:~# /usr/sbin/opensnoop-bpfcc 
-	PID    COMM               FD ERR PATH
-	766    vminfo              6   0 /var/run/utmp
-	562    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
-	562    dbus-daemon        18   0 /usr/share/dbus-1/system-services
-	562    dbus-daemon        -1   2 /lib/dbus-1/system-services
-	562    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/
______________________________________________________________________________________________________
-	Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное 
-	местоположение в /proc, где можно узнать версию ядра и релиз ОС.
-	
-	Ответ
-	системный вызов uname()
-	
-	 Part of the utsname information is also accessible  via  /proc/sys/ker‐
-        nel/{ostype, hostname, osrelease, version, domainname}.
_________________________________________________________________________________________
-	Чем отличается последовательность команд через ; и через && в bash? Например:
-	
-	Есть ли смысл использовать в bash &&, если применить set -e?
-	
-	Ответ
-	&& -  условный оператор, 
-	а ;  - разделитель последовательных команд

-	test -d /tmp/some_dir && echo Hi - в данном случае echo  отработает только при успешном заверщении команды test

-	set -e - прерывает сессию при любом ненулевом значении исполняемых команд в конвеере кроме последней.
-	в случае &&  вместе с set -e- вероятно не имеет смысла, так как при ошибке , выполнение команд прекратиться. 
___________________________________________________________________________________________________
-	Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
-	
-	Ответ
-	-e прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности 
-	-x вывод трейса простых команд 
-	-u неустановленные/не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и
-	выполнит завершение неинтерактивного вызова
-	-o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд.
__________________________________________________________________________________________________________
-	Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. 
-	В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. 
-	Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
-	
-	Ответ
-	Самые частые (описание топроное, но по руссски :) ):
-	S*(S,S+,Ss,Ssl,Ss+) - Процессы ожидающие завершения (спящие с прерыванием "сна")
-	I*(I,I<) - фоновые(бездействующие) процессы ядра
_________________________________________________________________________________________________________________
